# generated by Gemini as a test based on an upload of the Vinck et al. 2010 paper

import numpy as np

def ppc(phases):
    """
    Calculates the Pairwise Phase Consistency (PPC) for a set of phase values.

    The PPC is a bias-free measure of rhythmic neuronal synchronization, as
    described in:
    Vinck, M., van Wingerden, M., Womelsdorf, T., Fries, P., & Pennartz, C. M. A.
    (2010). The pairwise phase consistency: a bias-free measure of rhythmic
    neuronal synchronization. NeuroImage, 51(1), 112–122.

    Parameters
    ----------
    phases: A 1D numpy array 
            Phase values in radians. The shape should
            be (n_observations,). For example, these could be the phases
            of spike times relative to an LFP oscillation.

    Returns
    -------
    ppc: float
        The PPC value, a float. According to the paper, this is an unbiased
        estimator of the squared Phase-Locking Value (PLV^2). Returns numpy.nan
        if there are fewer than two phase values.
    """
    n = len(phases)

    # PPC is not defined for less than 2 observations, as it requires pairs.
    if n < 2:
        print("Warning: Cannot calculate PPC with less than 2 observations.")
        return np.nan

    # The formula for the sample PPC is:
    # PPC = (2 / (N * (N - 1))) * sum(cos(theta_j - theta_k)) for all unique pairs j < k
    # This is equivalent to the average of the dot products of all unique pairs
    # of phase vectors, where each phase is represented as a unit vector on a circle.
    #
    # Instead of using slow, explicit loops, we can compute this efficiently
    # using numpy's broadcasting capabilities.

    # 1. Create a matrix of all phase differences.
    # The element at (j, k) will be phases[j] - phases[k].
    phase_diffs = np.subtract.outer(phases, phases)

    # 2. Compute the cosine of all phase differences. This is equivalent to
    # computing the dot product for each pair of phase vectors.
    # cos(a - b) = cos(a)cos(b) + sin(a)sin(b)
    cos_phase_diffs = np.cos(phase_diffs)

    # 3. The formula requires summing over unique pairs (j < k). This corresponds
    # to the sum of the elements in the upper (or lower) triangle of the
    # cos_phase_diffs matrix. We can get this by taking the total sum,
    # subtracting the diagonal, and dividing by 2.
    # The diagonal consists of cos(0)=1 for all elements.
    sum_of_diagonal = n # np.trace(cos_phase_diffs)
    total_sum = np.sum(cos_phase_diffs)

    # Sum of the cosine of differences for all unique pairs.
    sum_of_pairs = (total_sum - sum_of_diagonal) / 2.0

    # 4. The number of unique pairs is N * (N - 1) / 2.
    n_pairs = (n * (n - 1)) / 2.0

    # 5. The PPC is the average of the summed values.
    ppc = sum_of_pairs / n_pairs

    return ppc


def ppc2(phases):
    """
    Alternative calculation of the Pairwise Phase Consistency (PPC2)
    for a set of phase values.

    Created by Greg Glickert

    Parameters
    ----------
    phases: A 1D numpy array 
            Phase values in radians. The shape should
            be (n_observations,). For example, these could be the phases
            of spike times relative to an LFP oscillation.

    Returns
    -------
    ppc2: float
        The PPC value, a float. This is an unbiased estimator of the squared
        Phase-Locking Value (PLV^2) as described in Vinck et al. (2010).
        Returns 0 if there are fewer than two phase values.
    """
    # Calculate PPC2 according to Vinck et al. (2010), Equation 6
    n = len(phases)

    if n <= 1:
        print("Warning: Cannot calculate PPC with less than 2 observations.")
        return np.nan


    # Convert phases to unit vectors in the complex plane
    unit_vectors = np.exp(1j * phases)

    # Calculate the resultant vector
    resultant_vector = np.sum(unit_vectors)

    # PPC2 = (|∑(e^(i*φ_j))|² - n) / (n * (n - 1))
    ppc2 = (np.abs(resultant_vector) ** 2 - n) / (n * (n - 1))

    return ppc2

# --- Example Usage ---
if __name__ == '__main__':
    # Generate some example data
    # Seed for reproducibility
    np.random.seed(0)

    # Case 1: Phases are highly consistent (clustered around pi/4)
    # We expect a PPC value close to 1.
    consistent_phases = np.random.normal(loc=np.pi/4, scale=0.1, size=100)
    ppc1_1 = ppc(consistent_phases)
    ppc1_2 = ppc2(consistent_phases)
    print(f"Consistent Phases PPC: {ppc1_1:.4f} (ppc2: {ppc1_2:.4f})") # Expect values close to 1.0

    # Case 2: Phases are uniformly distributed (no consistency)
    # We expect a PPC value close to 0.
    random_phases = np.random.uniform(low=-np.pi, high=np.pi, size=100)
    ppc2_1 = ppc(random_phases)
    ppc2_2 = ppc2(random_phases)
    print(f"Random Phases PPC: {ppc2_1:.4f} (ppc2: {ppc2_2:.4f})") # Expect values close to 0.0

    # Case 3: Bimodal distribution, 180 degrees apart
    # We still expect a PPC value close to 0 because on average, the dot product is 0.
    phases_part1 = np.random.normal(loc=0, scale=0.1, size=50)
    phases_part2 = np.random.normal(loc=np.pi, scale=0.1, size=50)
    bimodal_phases = np.concatenate([phases_part1, phases_part2])
    ppc3_1 = ppc(bimodal_phases)
    ppc3_2 = ppc2(bimodal_phases)
    print(f"Bimodal (180 deg apart) Phases PPC: {ppc3_1:.4f} (ppc2: {ppc3_2:.4f})") # Expect values close to -1.0 or 0.0

    # Case 4: Fewer than 2 observations
    ppc4_1 = ppc(np.array([1.0]))
    ppc4_2 = ppc2(np.array([1.0]))
    print(f"Fewer than 2 phases PPC: {ppc4_1} (ppc2: {ppc4_2})")